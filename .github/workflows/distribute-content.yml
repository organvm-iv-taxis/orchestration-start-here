name: Distribute Content

# POSSE automation for ORGAN-V essays and announcements.
# Distributes content to configured channels when ready-to-distribute label is applied.
# Parses structured metadata from issue body (DISTRIBUTIO format), posts to
# Mastodon and Discord, then auto-closes the issue with a distribution report.
# Requires secrets: MASTODON_TOKEN, DISCORD_WEBHOOK
# Optional: LINKEDIN_TOKEN, GHOST_ADMIN_KEY

on:
  issues:
    types: [labeled]

jobs:
  distribute:
    if: contains(github.event.label.name, 'ready-to-distribute')
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - uses: actions/checkout@v4

      - name: Extract and Distribute Content
        id: metadata
        run: |
          python3 << 'PYEOF'
          import json
          import os
          import re
          import subprocess

          title = os.environ.get("ISSUE_TITLE", "New content")
          body = os.environ.get("ISSUE_BODY", "")
          number = os.environ.get("ISSUE_NUMBER", "0")
          repo = os.environ.get("GITHUB_REPO", "")
          mastodon_token = os.environ.get("MASTODON_TOKEN", "")
          mastodon_instance = os.environ.get("MASTODON_INSTANCE", "https://mastodon.social")
          discord_webhook = os.environ.get("DISCORD_WEBHOOK", "")

          # Strip "Essay Detected: " prefix from issue title
          clean_title = title
          if clean_title.startswith("Essay Detected: "):
              clean_title = clean_title[len("Essay Detected: "):]

          # Parse structured fields from issue body (DISTRIBUTIO format)
          def extract_field(field_name, text):
              match = re.search(rf'\*\*{field_name}:\*\*\s*(.+)', text)
              return match.group(1).strip() if match else ''

          excerpt = extract_field('Excerpt', body)
          tags_str = extract_field('Tags', body)
          category = extract_field('Category', body)
          reading_time = extract_field('Reading Time', body)

          # Extract essay URL — prefer structured field, fall back to regex scan
          essay_url = extract_field('URL', body)
          if not essay_url:
              url_match = re.search(r'https://organvm-v-logos\.github\.io/public-process/[^\s)]+', body)
              if url_match:
                  essay_url = url_match.group(0)
          if not essay_url:
              essay_url = f"https://github.com/{repo}/issues/{number}"

          # Fall back excerpt: first non-header, non-separator line from body
          if not excerpt:
              for line in body.strip().split("\n"):
                  line = line.strip()
                  if line and not line.startswith("#") and not line.startswith("---") and not line.startswith("**"):
                      excerpt = line[:280]
                      break
          if not excerpt:
              excerpt = clean_title

          # Convert tags to hashtags: "ai-conductor, recursion" -> "#aiconductor #recursion"
          hashtags = '#organvm #buildinginpublic'
          if tags_str:
              tag_list = [t.strip() for t in tags_str.split(',')]
              tag_hashtags = ' '.join(f"#{t.replace('-', '').replace(' ', '')}" for t in tag_list if t)
              if tag_hashtags:
                  hashtags = f"{tag_hashtags} {hashtags}"

          print(f"Title: {clean_title}")
          print(f"Excerpt: {excerpt[:80]}...")
          print(f"URL: {essay_url}")
          print(f"Hashtags: {hashtags}")

          results = {}

          # -- Post to Mastodon --
          if mastodon_token:
              status_text = f"{clean_title}\n\n{excerpt[:280]}\n\n{essay_url}\n\n{hashtags}"
              r = subprocess.run(
                  ['curl', '-s', '-w', '\n%{http_code}',
                   f'{mastodon_instance}/api/v1/statuses',
                   '-H', f'Authorization: Bearer {mastodon_token}',
                   '-F', f'status={status_text}',
                   '-F', 'visibility=public'],
                  capture_output=True, text=True
              )
              parts = r.stdout.strip().rsplit('\n', 1)
              http_code = parts[-1] if len(parts) > 1 else '0'
              if http_code.isdigit() and 200 <= int(http_code) < 300:
                  results['mastodon'] = 'success'
                  print(f"Posted to Mastodon (HTTP {http_code})")
              else:
                  results['mastodon'] = 'failed'
                  print(f"Mastodon post failed (HTTP {http_code})")
          else:
              results['mastodon'] = 'not configured'

          # -- Post to Discord --
          if discord_webhook:
              footer_text = category if category else 'organvm -- building in public'
              if reading_time:
                  footer_text = f"{footer_text} | {reading_time}"

              payload = json.dumps({
                  "embeds": [{
                      "title": clean_title,
                      "description": excerpt[:2048],
                      "url": essay_url,
                      "color": 5814783,
                      "footer": {"text": footer_text}
                  }]
              })
              r = subprocess.run(
                  ['curl', '-s', '-o', '/dev/null', '-w', '%{http_code}',
                   discord_webhook, '-X', 'POST',
                   '-H', 'Content-Type: application/json',
                   '-d', payload],
                  capture_output=True, text=True
              )
              http_code = r.stdout.strip()
              if http_code.isdigit() and 200 <= int(http_code) < 300:
                  results['discord'] = 'success'
                  print(f"Posted to Discord (HTTP {http_code})")
              else:
                  results['discord'] = 'failed'
                  print(f"Discord post failed (HTTP {http_code})")
          else:
              results['discord'] = 'not configured'

          # Write outputs for downstream steps
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"title={clean_title}\n")
              f.write(f"excerpt={excerpt}\n")
              f.write(f"url={essay_url}\n")
              for k, v in results.items():
                  f.write(f"{k}={v}\n")

          PYEOF
        env:
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          GITHUB_REPO: ${{ github.repository }}
          MASTODON_TOKEN: ${{ secrets.MASTODON_TOKEN }}
          MASTODON_INSTANCE: ${{ vars.MASTODON_INSTANCE || 'https://mastodon.social' }}
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}

      - name: Post to LinkedIn
        id: linkedin
        if: env.LINKEDIN_TOKEN != ''
        env:
          LINKEDIN_TOKEN: ${{ secrets.LINKEDIN_TOKEN }}
          LINKEDIN_PERSON_ID: ${{ vars.LINKEDIN_PERSON_ID }}
          CONTENT_TITLE: ${{ steps.metadata.outputs.title }}
          CONTENT_EXCERPT: ${{ steps.metadata.outputs.excerpt }}
          CONTENT_URL: ${{ steps.metadata.outputs.url }}
        run: |
          python3 << 'PYEOF'
          import json
          import os
          import subprocess

          token = os.environ.get("LINKEDIN_TOKEN", "")  # allow-secret
          person_id = os.environ.get("LINKEDIN_PERSON_ID", "")
          title = os.environ.get("CONTENT_TITLE", "")
          excerpt = os.environ.get("CONTENT_EXCERPT", "")
          url = os.environ.get("CONTENT_URL", "")

          payload = json.dumps({
              "author": f"urn:li:person:{person_id}",
              "lifecycleState": "PUBLISHED",
              "specificContent": {
                  "com.linkedin.ugc.ShareContent": {
                      "shareCommentary": {
                          "text": f"{title}\n\n{excerpt}\n\n#organvm #buildinginpublic #creativetechnology"
                      },
                      "shareMediaCategory": "ARTICLE",
                      "media": [{
                          "status": "READY",
                          "originalUrl": url,
                          "title": {"text": title}
                      }]
                  }
              },
              "visibility": {
                  "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC"
              }
          })

          r = subprocess.run(
              ['curl', '-s', '-o', '/dev/null', '-w', '%{http_code}',
               'https://api.linkedin.com/v2/ugcPosts',
               '-X', 'POST',
               '-H', f'Authorization: Bearer {token}',
               '-H', 'Content-Type: application/json',
               '-H', 'X-Restli-Protocol-Version: 2.0.0',
               '-d', payload],
              capture_output=True, text=True
          )
          http_code = r.stdout.strip()
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              if http_code.isdigit() and 200 <= int(http_code) < 300:
                  f.write("linkedin=success\n")
                  print(f"Posted to LinkedIn (HTTP {http_code})")
              else:
                  f.write("linkedin=failed\n")
                  print(f"LinkedIn post failed (HTTP {http_code})")
          PYEOF

      - name: Publish to Ghost Newsletter
        id: ghost
        if: env.GHOST_ADMIN_KEY != ''
        env:
          GHOST_ADMIN_KEY: ${{ secrets.GHOST_ADMIN_KEY }}
          GHOST_URL: ${{ vars.GHOST_URL }}
          CONTENT_TITLE: ${{ steps.metadata.outputs.title }}
          CONTENT_EXCERPT: ${{ steps.metadata.outputs.excerpt }}
          CONTENT_URL: ${{ steps.metadata.outputs.url }}
        run: |
          python3 << 'PYEOF'
          import base64
          import hashlib
          import hmac
          import json
          import os
          import subprocess
          import time

          admin_key = os.environ.get("GHOST_ADMIN_KEY", "")
          ghost_url = os.environ.get("GHOST_URL", "")
          title = os.environ.get("CONTENT_TITLE", "")
          excerpt = os.environ.get("CONTENT_EXCERPT", "")
          url = os.environ.get("CONTENT_URL", "")

          key_id, key_secret_hex = admin_key.split(":")
          key_secret = bytes.fromhex(key_secret_hex)
          iat = int(time.time())
          header = base64.urlsafe_b64encode(json.dumps({"alg":"HS256","kid":key_id,"typ":"JWT"}).encode()).rstrip(b'=').decode()
          payload_jwt = base64.urlsafe_b64encode(json.dumps({"iat":iat,"exp":iat+300,"aud":"/admin/"}).encode()).rstrip(b'=').decode()
          signature = base64.urlsafe_b64encode(hmac.new(key_secret, f"{header}.{payload_jwt}".encode(), hashlib.sha256).digest()).rstrip(b'=').decode()
          token = f"{header}.{payload_jwt}.{signature}"  # allow-secret

          post_payload = json.dumps({
              "posts": [{
                  "title": title,
                  "html": f"<p>{excerpt}</p><p><a href='{url}'>Read the full essay</a></p>",
                  "status": "draft",
                  "tags": ["organvm", "building-in-public"]
              }]
          })

          r = subprocess.run(
              ['curl', '-s', '-o', '/dev/null', '-w', '%{http_code}',
               f'{ghost_url}/ghost/api/admin/posts/',
               '-X', 'POST',
               '-H', f'Authorization: Ghost {token}',
               '-H', 'Content-Type: application/json',
               '-d', post_payload],
              capture_output=True, text=True
          )
          http_code = r.stdout.strip()
          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              if http_code.isdigit() and 200 <= int(http_code) < 300:
                  f.write("ghost=success\n")
                  print(f"Published to Ghost (HTTP {http_code})")
              else:
                  f.write("ghost=failed\n")
                  print(f"Ghost publish failed (HTTP {http_code})")
          PYEOF

      - name: Log Distribution Results
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const mastodon = '${{ steps.metadata.outputs.mastodon }}' || 'not configured';
            const discord = '${{ steps.metadata.outputs.discord }}' || 'not configured';
            const linkedin = '${{ steps.linkedin.outputs.linkedin }}' || 'not configured';
            const ghost = '${{ steps.ghost.outputs.ghost }}' || 'not configured';

            const icon = (s) => s === 'success' ? '✅' : s === 'failed' ? '❌' : '⚪';

            const channels = [
              `| Mastodon | ${icon(mastodon)} | ${mastodon} |`,
              `| Discord | ${icon(discord)} | ${discord} |`,
              `| LinkedIn | ${icon(linkedin)} | ${linkedin} |`,
              `| Ghost Newsletter | ${icon(ghost)} | ${ghost} |`,
            ].join('\n');

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Distribution Report\n\n| Channel | Status | Detail |\n|---------|--------|--------|\n${channels}\n\n---\n*Generated by distribute-content workflow (DISTRIBUTIO Sprint)*`
            });

      - name: Auto-close distributed issue
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            // Add 'distributed' label
            try {
              await github.rest.issues.addLabels({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: ['distributed']
              });
            } catch (e) {
              // Label may not exist yet — create it
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: 'distributed',
                  color: '6f42c1',
                  description: 'Content has been distributed via POSSE pipeline'
                });
                await github.rest.issues.addLabels({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  labels: ['distributed']
                });
              } catch (e2) {
                console.log('Could not add distributed label:', e2.message);
              }
            }

            // Close the issue
            await github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              state_reason: 'completed'
            });
